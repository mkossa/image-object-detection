# image-object-detection

HTTP REST API for a service that ingests user images, analyzes them for object detection,
and returns the enhanced content.

## Config and Setup

### Postgres Database Setup

This app requires a postgres database instance. There are some [initial database setup commands](resources/db-init.sql) that need to be run in order to create the database, create a database user, and build the tables the app will use if not already present.

Once available, create the following file with the corresponding data:

`resources/db-config.edn`

```
{:dbtype "postgresql"
 :dbname "image_object_detection"
 :user "your_username"
 :password "your_password"
 :host "your_host_ip"}
```

### Imagga API Credentials and Configs

You will also need to get an api-key/api-secret from [Imagga](https://imagga.com) in order to process object detection on images.

Once you have the api-key/api-secret, create the following file with the corresponding data:

`resources/imagga-config.edn`

```
{:api-key "your-api-key"
 :api-secret "your-api-secret"}
```

## Usage

> **_NOTE:_**  Run all commands at project root

The API runs on port 3001

In order to run the program locally:

`lein run`

In order to run the tests:

`lein test`

Additionally you can create an uberjar:

`lein uberjar`

and run it with:

```
$ java -jar ./target/uberjar/image-object-detection-0.1.0-SNAPSHOT-standalone.jar
```

## Endpoints

### POST /images

This endpoint allows a user to provide an image to the application and optionally request object detection on the image.

#### Request

```
{
    (required) image_url: string
               OR
               image_file: string
    (optional) label: string
    (optional) detect_objects: boolean
}
```

Either an `image_url` or `image_file` is required to represent the image the application will ingest.
The `label` field is optional; however, a random label will be assigned to the image if one is not provided.
The `detect_objects` field is also optional, and defaults to false. This boolean determines whether or not object detection should be performed on the image.

#### Response

```
{
  id: int,
  label: string,
  image_location: string,
  upload_time: string UTC timestamp,
  objects_detected: [
    {
        confidence: float
        object: string
    }
    ...
  ]
}
```

The `id` is the unique key for the image generated by the database.
The `label` will either be the value provided in the request or label-XXXXXXXX where each X is a random hexadecimal value.
The `image_location` is either the provided `image_url` or `image_file` from the request.
The `upload_time` denotes when the image was added to the database.
The `objects_detected` will only be returned if `detect_objects` was set to true in the request. This key is a list of json objects that consist of an `object` that was detected and the level of `confidence` that object is in the image.

### GET /images

This endpoint returns all images and their metadata that have been provided to the application.

#### Optional Filter

Additionally, a query string paramter can be provided to filter the result set that is returned.

`/images?objects="object1,object2,..."`

If this filter is provided, all images that contains **any** of the objects in the comma-separated string will be returned.

#### Response

```
[
    {
        id: int,
        label: string,
        image_location: string,
        upload_time: string UTC timestamp,
        objects_detected: [
            {
                confidence: float
                object: string
            }
            ...
        ]
    }
    ...
]
```

The `id` is the unique key for the image generated by the database.
The `label` will either be the value provided in the request or label-XXXXXXXX where each X is a random hexadecimal value.
The `image_location` is either the provided `image_url` or `image_file` from the request.
The `upload_time` denotes when the image was added to the database.
The `objects_detected` will only be returned if `detect_objects` was set to true in the request. This key is a list of json objects that consist of an `object` that was detected and the level of `confidence` that object is in the image.

### GET /images/`{id}`

This endpoint returns a single image based on its `id`.

#### Response

```
{
  id: int,
  label: string,
  image_location: string,
  upload_time: string UTC timestamp,
  objects_detected: [
    {
        confidence: float
        object: string
    }
    ...
  ]
}
```

The `id` is the unique key for the image generated by the database.
The `label` will either be the value provided in the request or label-XXXXXXXX where each X is a random hexadecimal value.
The `image_location` is either the provided `image_url` or `image_file` from the request.
The `upload_time` denotes when the image was added to the database.
The `objects_detected` will only be returned if `detect_objects` was set to true in the request. This key is a list of json objects that consist of an `object` that was detected and the level of `confidence` that object is in the image.

## Assumptions

Due to ambiguity in some requirements the following assumptions were made:

1. I assumed that caching (based on file path or url) should not be used on this project due to the inability to know when to invalidate the cache.

    **For Example:**

        A user requests object detection for the image file C:\a.jpg.
        5 minutes later the user requests object detection for the same file location (C:\a.jpg).
        If the underlying image changed between the 2 requests, it would be incorrect to send back the object detection determined in the first request.
2. I am assuming I should have the file path or url location provided via a string in the JSON request as opposed to using multipart form-body encoding based on requirements. I also assumed I should store the url or file path as metadata with the image. Additionally, I am storing metadata on when the image was added to the database.
3. I assumed the actual data for the image did not need to be saved, and instead only stored the location the image came from (url or file) and additional metadata. I made this assumption since the API takes in a URL or file path and an encoded image could take up a lot of space. However, additional work could be completed to add this feature if it is desired.
4. When a query parameter is provided in the GET /images endpoint I assumed that all images that match ANY of the objects should be returned instead of returning images that had detected ALL of the objects in the filter.
    **For Example:**

        Assuming "dog,cat" means return any image with a dog OR cat and not return all images with both a dog AND cat.

## Possible Enhancements

1. Dockerize the application with a database that automatically initializes for ease of setup.
2. Build a UI to interact with the Application.
3. Give users the ability to search for images using AND and OR conditions.
4. Allow users to search for images by label.
5. Update integration tests to use test docker DB instead of `with-redef` side-effects.
6. Allow users to provide a minimum confidence level of object detection to keep as metadata with the image.
7. Allow a user to go back and run object detection on an image that was originally uploaded without object detection.
